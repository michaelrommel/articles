---
thumbnailUrl: "/articles/assets/2025-06-15-tonic-proxy/thumbnail.png"
thumbnailTitle: "Image showing a trace log with a marked error segment"
structuredData: {
    "@context": "https://schema.org",
    "@type": "Article",
    author: {
        "@type": "Person",
        "name": "Michael Rommel",
        "url": "https://michaelrommel.com/info/about",
        "image": "https://avatars.githubusercontent.com/u/919935?s=100&v=4"
    },
    "dateModified": "2025-06-15T19:20:09+02:00",
    "datePublished": "2025-06-15T19:20:12+02:00",
    "headline": "Proxy Support for Rust tonic GRPC applications",
    "abstract": "Adding support for a proxied connection to a tonic application proved to be pretty cumbersome, aka three evenings in hell."
}
tags: ["new", "create", "code", "rust", "proxy"]
published: true
---

# Proxy Support for Rust tonic GRPC applications

## Motivation

If you read the previous article, you know, that I added a remote shell
functionality to my blog. One motivation was really the idea, to be able
to halt a CI/CD script and debug a container at runtime. But sometimes, the
servers running the pipelines are inside a firewall or lab network without
direct internet connectivity.

The browser portion is usually not a problem, but here we were talking about the
sshx client app, that talks HTTPS/2.0 with GRPC running through a channel of
that connection. Proxy functionality does not come out of the box with any 
usual tonic application, especially, if the code is being autogenerated from a 
protobuf file.


## Trial and Error Method

So I set out to find a Rust crate, that -- at least on paper -- claims to
support proxies. I found the following possible candidates:

- hyper_util::client::legacy::connect::proxy (deprecated, incompatible)
- hyper-proxy (dead)
- hyper-proxy2 (mostly dead)
- hyper-http-proxy (unresponsive)
- reqwest (incompatible)


### What to patch -- the original code

The source code I had, was build along the lines of the standard tonic examples,
where the code generated by prost calls out for a `connect()` method.

```rust
async fn connect(origin: &str) -> Result<EchoServiceClient<Channel>, tonic::transport::Error> {
    EchoServiceClient::connect(String::from(origin)).await
}
```

So the easiest way was, to instead of calling the generated method, write a
completely new version of it, and still make use of the other parts of the
generated service.


### Incompatible Crates

The proxy implementation of the hyper_util crate would probably have been ok,
were it not for the missing implementation of the `Clone` trait. The Socks5
implementation has that trait, so I am at a loss, why this would be missing from
the http/s Tunnel implementation, but here we are.

The code was something like this:

```rust
let proxy_uri = "http://192.168.13.135:3128".parse().unwrap();
let proxy = Tunnel::new(proxy_uri, connector);
let client = Client::builder(TokioExecutor::new())
    .http2_only(true)
    .build(proxy);
let destination = origin.parse().unwrap();
let c = EchoServiceClient::with_origin(client, destination);
Ok(c)
```

The reqwest crate is maintained, albeit the sheer number of issues and PRs tells
a lot about its state. The types are not compatible with the ones the tonic
implementation expects and I could not get it to compile. That is a shame, since
it seemed to be the natural successor of the hyper::client implementation, that
was moved to "legacy".

```rust
let client = Client::builder()
    .proxy(reqwest::Proxy::https("http://192.168.13.135:3128/")?)
    .build()?;
let destination = origin.parse().unwrap();
let c = SshxServiceClient::with_origin(client, destination);
Ok(c)
```


### The `hyper-http-proxy` Crate

The remaining choice was this crate, that I could get to compile and also make
use of the proxy. In my tests everything started out fine, I saw the requests
going through the proxy directly to the http endpoing of the application.

But soon enough things fell apart, when I was trying to use the proxy to connect
to a real `https` endpoint with encryption. Here the connecion was forwarded
from the proxy to the nginx reverse proxy in front of the tonic application and
the nginx log only showed the http2 prior knowledge packets and then a `GOAWAY`
followed.

The code at this point was:

```rust
let connector = HttpConnector::new();
let proxy = {
    let proxy_uri = "http://192.168.13.135:3128".parse().unwrap();
    let mut proxy = Proxy::new(Intercept::All, proxy_uri);
    proxy.force_connect();
    ProxyConnector::from_proxy_unsecured(connector, proxy)
};
let client = Client::builder(TokioExecutor::new())
    .http2_only(true)
    .build(proxy);
let destination = origin.parse().unwrap();
let c = SshxServiceClient::with_origin(client, destination);
Ok(c)
```

Since the error was related to the https part of the connection, because the
connections via the proxy to the unencrypted endpoint were fine. So I thought
that the underlying `http` connector was the issue and started to replace that.

```rust
let connector = HttpsConnectorBuilder::new()
    .with_native_roots()
    .expect("no native root CA certificates found")
    .https_or_http()
    .enable_all_versions()
    .build();
let client = hyper_util::client::legacy::Client::builder(TokioExecutor::new())
    .http2_only(true)
    .build(connector);
let destination = origin.parse().unwrap();
let c = SshxServiceClient::with_origin(client, destination);
Ok(c)
```

Still the error was pretty much the same. I could use that program to connect
directly to the application with http and https.

And as I started to hook the proxy in, I could connect to the http endpoint with
the proxy but not to the https endpoint with the proxy. The proxy config at that
point was like this:

```rust
let connector = HttpsConnectorBuilder::new()
    .with_native_roots()
    .expect("no native root CA certificates found")
    .https_or_http()
    .enable_all_versions()
    .build();
let proxy = {
    let proxy_uri = "http://192.168.13.135:3128".parse().unwrap();
    let mut proxy = Proxy::new(Intercept::All, proxy_uri);
    proxy.force_connect();
    ProxyConnector::from_proxy_unsecured(connector, proxy);
}
let client = hyper_util::client::legacy::Client::builder(TokioExecutor::new())
    .http2_only(true)
    .build(proxy);
let destination = origin.parse().unwrap();
let c = SshxServiceClient::with_origin(client, destination);
Ok(c)
```


## The solution

After tearing my receding hair out in hours of troubleshooting, I busted out
wireshark and increased RUST_LOG to `debug`. Then I saw the missing piece: the
Tlsconnection that was created by the `hyper-http-proxy` crate did not specify
the ALPN (Application Layer Protocol Negotiation) to `h2`. This would have been
the correct negotiation, but the yellow marked part was initially missing:

![Rust Log Screenshot](/articles/assets/2025-06-15-tonic-proxy/full_log.png)

So the nginx never responded with the support of the HTTP/2 protocol and
therefore the sent packets by the application were misinterpreted resulting in
those log lines:

```log
192.168.13.135 - - [15/Jun/2025:11:19:59 +0200] "PRI * HTTP/2.0" 400 150 "-" "-"
192.168.13.135 - - [15/Jun/2025:11:20:47 +0200] "PRI * HTTP/2.0" 400 150 "-" "-"
192.168.13.135 - - [15/Jun/2025:11:28:59 +0200] "PRI * HTTP/2.0" 400 150 "-" "-"
192.168.13.135 - - [15/Jun/2025:11:45:47 +0200] "PRI * HTTP/2.0" 400 150 "-" "-"
192.168.13.135 - - [15/Jun/2025:11:46:24 +0200] "PRI * HTTP/2.0" 400 150 "-" "-"
192.168.13.135 - - [15/Jun/2025:14:05:36 +0200] "PRI * HTTP/2.0" 400 150 "-" "-"
```

The solution was to configure the proxy connection initially as unencrypted and
then create a special `rustls` config with the appropriate ALPN setting and make
the ProxyConnector use this config. After that, it works fine now.

```rust
let connector = HttpConnector::new();
let proxy = {
    let proxy_uri = "http://192.168.13.135:3128".parse().unwrap();
    let mut proxy = Proxy::new(Intercept::All, proxy_uri);
    proxy.force_connect();
    let mut pconnect = ProxyConnector::from_proxy_unsecured(connector, proxy);
    let config = tokio_rustls::rustls::ClientConfig::builder();
    let config = config.with_native_roots()?;
    let mut config = config.with_no_client_auth();
    config.alpn_protocols = vec![b"h2".to_vec()];
    let cfg = Arc::new(config);
    let tls = TlsConnector::from(cfg);
    pconnect.set_tls(Some(tls));
    pconnect
};
let client = Client::builder(TokioExecutor::new())
    .http2_only(true)
    .build(proxy);
let destination = origin.parse().unwrap();
let c = SshxServiceClient::with_origin(client, destination);
Ok(c)
```


## Conclusion

I was really several times at the brink of giving up. The type and trait system
of Rust makes it hard to find crates, that fit into an existing stack of
modules. The community was spectacularly unhelpful, not even responding to any
of my questions or issues. I understand that without being a sponsor or
otherwise financially supporting the engineers, there cannot be an expectation
that anyone helps out and that is their good right.

I just compare that with the experience from the svelte community that I had
earlier this month, where I at least got feedback, that: either they cannot help
or that pointed me in the right direction. I even had one kind person that even
provided a playground example of how to do things. Miles better, I'd say...

Solving the mystery of the broken connection made my day. I don't know why, but
unresolved errors leave me in a state of mind, where I subconsciously tend to
the problem all the time and it drags me down. It is a constant mental burden
that I carry around: I tells me, that I am not good enough to solve a problem
and that my knowledge and skills are inadequate and so on.

This is a huge problem for me, that I always need a proper closure of a problem.
Thank god I am not in physics, where the inexplicable is the norm.

As always questions or suggestions to this article can be raised
[here](https://github.com/michaelrommel/articles/discussions/).

